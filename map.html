<!DOCTYPE html>
<!--SOURCE: view-source:http://techslides.com/demos/d3/worldmap-template-d3v4.html-->
<!--SOURCE: https://stackoverflow.com/questions/47917730/d3-line-and-points-on-map-from-csv-data-->
<meta charset="utf-8"/>
<title>VILMA | SimpleMap</title>
<style>
.country:hover{
  stroke: #7d7d7d;
  stroke-width: 0.5px;
}
#container {
  width:100%;
  height:100%;
  overflow:hidden;
  background: #fff;
}
.gpoint:hover{
	stroke:white;
	stroke-width: 2px;
}
.route{
	  fill: none;	
}
.route:hover{
	stroke-width: 4px;
}
.arc path {
    stroke: #fff;
}
</style>
</head>
<body>

<div id="container"></div>

<script src="js/d3.min.js"></script>
<script src="js/topojson.v1.min.js"></script>
<script src="js/d3-queue.min.js"></script>
<script src="node_modules/underscore/underscore-min.js"></script>

<script>
/****************************************************************************************************************************/
var container = document.getElementById('container');
var width = container.offsetWidth;
var height = width/1.5;
  
var projection = d3.geoMercator()
				 .center([25, 43])
				 .translate([(width/2), (height/2)])
				 .scale(950);

var path = d3.geoPath()
		   .projection(projection);

var svg = d3.select("#container")
		  .append("svg")
		  .attr("width", width)
		  .attr("height", height)
		  .append("g");

var g = svg.append("g");
<<<<<<< Updated upstream

=======
>>>>>>> Stashed changes
/****************************************************************************************************************************/
//Alle Daten werden über die queue Funktion parallel reingeladen, hier auf die Reihenfolge achten
function loaded(error, world, nodes, flows) {

//world data
var countries = topojson.feature(world, world.objects.countries).features;
draw(countries);

//nodes data
var nodesData = {};
nodes.forEach(function(node) {
	nodesData[node.city] = {'city':node.city,'lon':node.lon,'lat':node.lat};
});

//flows data
var flowsData = {};
var flowsValues = [];   //get all flow-values from flowsData to use for path stroke-width
var links = [];         //for multiple links with different bents
flows.forEach(function(flow) {
		flowsData[flow.id] = {'id':flow.id,'source':flow.source,'target':flow.target,'value':flow.value,'type':flow.type};
        flowsValues.push(parseInt(flow.value));
        data = {source: flow.source, target: flow.target};
        links.push(data);
	});
    console.log("flowsData " + flowsData)
    console.log("flowsValues " + flowsValues)
    console.log("links " + links)

/****************************************************************************************************************************/

/*
Define data from flowsData: source_x, source_y, source_coord,target_x,target_y,target_coord
*/
for(key in flowsData) {
   // console.log(key)
//source
    source = flowsData[key].source;					//die source wird aus den flowsData je key gezogen
    sourceX = nodesData[source]['lon'];				//die source aus flowsData ist der key in nodesData und daraus werden koordinaten gezogen
    sourceY = nodesData[source]['lat'];
    sourceCoords = [sourceX, sourceY];
//target	
    target = flowsData[key].target;
    targetX = nodesData[target]['lon'];
    targetY = nodesData[target]['lat'];
    targetCoords = [targetX, targetY];
//flow für Krümmung
<<<<<<< Updated upstream
    flow = [source, target]
   console.log(flow)


    /* Pseudocode, um die Anzahl gleicher flows zu kriegen

    var flowQuantity = 0;

	for each source, target same
	- count + 1, wenn source & target in flowsData gleich sind 
	- if (count = 7) {return bend 0:0.7;}
		else if (count = 6) {return bend 0:0.6;}
	array.length()
	if (array.length = 7) {return bend 0:0.7;}
	*/

//color	
    color = flowsData[key].type
=======
    flow = [source, target];

//color
    color = flowsData[key].type;
>>>>>>> Stashed changes

//define strokeWidth
    maxValue = Math.max.apply(null, flowsValues);
	maxWidth = 12;
	width= flowsData[key].value;

    strokeWidth = width / maxValue * maxWidth;


    /***********************************************************************************************************************/
// Anzahl der flows mit gleicher source und gleichem target
// source: http://bl.ocks.org/thomasdobber/9b78824119136778052f64a967c070e0
    console.log(links)

    _.each(links, function(link){
        var same = _.where(links, {
            'source':link.source,
            'target':link.target
        });
        var sameAlt = _.where(links, {
            'source':link.target,
            'target':link.source
        });
        var sameAll = same.concat(sameAlt);

        _.each(sameAll, function (s,i) {
            s.sameIndex = (i + 1);
            s.sameTotal = (sameAll.length);
            s.sameTotalHalf = (s.sameTotal/2);
            s.sameUneven = ((s.sameTotal % 2) !== 0);
            s.sameMiddleLink = ((s.sameUneven == true) && (Math.ceil(s.sameTotalHalf) === s.sameIndex));
            s.sameLowerHalf = (s.sameIndex <= s.sameTotalHalf);
            s.sameArcDirection = s.sameLowerHalf ? 0 : 1;                           // Krümmung wird nach links und rechts aufgeteilt
            s.sameIndexCorrected = s.sameLowerHalf ? s.sameIndex : (s.sameIndex - Math.ceil(s.sameTotalHalf)); // sameIndex corrected gibt die untere und oebere hälfte an
        });

    });

    var maxSame = _.chain(links)
        .sortBy(function(x) {
            return x.sameTotal;
        })
        .last()
        .value().sameTotal;

    _.each(links, function(link) {
        link.maxSameHalf = Math.floor(maxSame / 3);
    });

    // drawPath
    drawPath(sourceX, sourceY, targetX, targetY, links)

    /***********************************************************************************************************************/
}; //End for key in flowsData


/* Pseudocode, um die Anzahl gleicher flows zu kriegen

for each source, target same
- count + 1, wenn source & target in flowsData gleich sind
- if (count = 7) {return bend 0:0.7;}
    else if (count = 6) {return bend 0:0.6;}
array.length()
if (array.length = 7) {return bend 0:0.7;}


Objekt mit denen, die gleich sind, anlegen

mit "where" (flows.foreach) arbeiten in schleife flow

*/
//**********************************************************************************************************************
// Adjust point size
// get values per source
// get the value for each individual source (that you find in node.city)
    var valuePerSource = {};
    var valuePerTarget = {};
    var valuePerPie = {};
    pointValueSource = [];
    pointValueTarget = [];

    //run through nodes and get the flow.values per flow.source and flow.target which are put into objects and arrays defined above
    nodes.forEach(function(node){
        // get value per source element
        var valueSource = 0;
        var valueTarget = 0;
        flows.forEach(function(flow){                       //  for each flow, if source == node.city add the flow.value to the defined value
            if (flow.source == node.city){
                //console.log(flow.value)
                valueSource = valueSource + parseInt(flow.value);
            }
            if (flow.target == node.city){
                valueTarget = valueTarget + parseInt(flow.value);
            }
        });

        valuePerSource[node.city] = valueSource;
        valuePerTarget[node.city] = valueTarget;
        valuePerPie[node.city] = [valueSource,valueTarget];
        pointValueSource.push(valuePerSource[node.city]);     //pointValue to get the values for calculating the max value
        pointValueTarget.push(valuePerTarget[node.city]);
    });


    // get point size
    maxSourceValue = Math.max.apply(null,pointValueSource);
    maxTargetValue = Math.max.apply(null,pointValueTarget);
    maxPointSize = 12;

    // run through valuePerSource

   for (var key in valuePerSource){
       pointSizeSource=(valuePerSource[key] / maxSourceValue * maxPointSize);             // calculate for each key the pointSize (value/maxValue * maxPointSize)
       valuePerSource[key] = pointSizeSource;                                          // like push: put the pointSize-Values into the object valuePerSource for each key
   };

   for (var key in valuePerTarget){
        pointSizeTarget=(valuePerTarget[key] / maxTargetValue * maxPointSize);
        valuePerTarget[key] = pointSizeTarget;
   }


// addpoint for each node
    nodes.forEach(function(node) {
        pointSizeSource=valuePerSource[node.city]                //under the valuePerSource object are pointSize - values per city which are calculated above; here we take the values
        pointSizeTarget=valuePerTarget[node.city]
        pieSize=valuePerPie[node.city]

        //pointSizeSum for the pie chart radius
        pointSizeSum = pointSizeSource + pointSizeTarget;


        addPoint(node.lon, node.lat,pointSizeSum,pieSize);
        //pieChart(pointSizeSum);
    });


//**********************************************************************************************************************

	
} //End loaded for queue

d3.queue().defer(d3.json, "data/countries.topo.json")
		.defer(d3.csv, "data/nodes.csv")
		.defer(d3.csv, "data/flows.csv")
		.await(loaded);		

/*
	FUNCTIONS
            draw
            addPoint
            makeArc
            specifyColor
	FUNCTIONS
*/
function draw(topo) {
  var country = g.selectAll(".country").data(topo);

  country.enter().insert("path")
      .attr("class", "country")
      .attr("d", path)
      .attr("id", function(d,i) { return d.id; })
      .style("fill", "lightgrey");
};

//function to add points to the map
<<<<<<< Updated upstream
function addPoint(lon, lat, pointSizeSum,pieSize) {
	  var x = projection([lon, lat])[0];
	  var y = projection([lon, lat])[1];
=======
function addPoint(lon, lat, pointSizeSum,pointValueSource,pointValueTarget) {
	  var x = projection([lon, lat])[0],
          y = projection([lon, lat])[1];

>>>>>>> Stashed changes

	  var point = g.append("g")
					.attr("class", "gpoint")
					.append("circle")
					.attr("cx", x)
					.attr("cy", y)
                    .style("fill","#c95f64")
                    .style("fill-opacity", 1.0)
					.attr("r", pointSizeSum);
<<<<<<< Updated upstream
};	
=======

/*
                   // Pie chart variables:
               // source: https://bl.ocks.org/Andrew-Reid/838aa0957c6492eaf4590c5bc5830a84

                   var g2 = svg.append("g");
                   var arc = d3.arc()
                       .innerRadius(0)
                       .outerRadius(radius);

                   var pie = d3.pie()
                       .sort(null)
                       .value(function(d) { return d; });

                   var pieColor = d3.schemeCategory10;
               // Draw pie charts
               // source: https://bl.ocks.org/Andrew-Reid/838aa0957c6492eaf4590c5bc5830a84
                       var points = g2.selectAll("g")
                           .enter()
                           .append("g")
                           .attr("cx", x)
                           .attr("cy", y)
                           .attr("class","pies")
                           .attr("r", pointSizeSum);
                           //.append("text")
                           //.attr("y", -radius - 5)
                           //.text("text",'hallo')
                           //.style('text-anchor','middle');

                       var pies = points.selectAll(".pies")
                       // split([","])
                           .data(function(d) { return pie(d.data.split(['-'])); })
                           .enter()
                           .append('g')
                           .attr('class','arc')
                           .append("path")
                           .attr('d',arc)
                           .attr("fill",function(d,i){
                               return color[i+1];
                           });
   */
};


//function makeArc, that is used for drawPath
function makeArc(sx, sy, tx, ty, links) {
					//sx,sy,tx,ty mit projection versehen
						var sxp = projection([sx,sy])[0],
							syp = projection([sx,sy])[1],
							txp = projection([tx,ty])[0],
							typ = projection([tx,ty])[1];
						
						var dx = txp - sxp,
							dy = typ - syp,
							dr = Math.sqrt(dx * dx + dy * dy),

                            unevenCorrection = (links.sameUneven ? 0 : 0.5),
                            arc = ((dr * links.maxSameHalf) / (links.sameIndexCorrected - unevenCorrection));

                            if (links.sameMiddleLink) {
                                arc = 0;

                            }
    console.log("unevenCorrection " + unevenCorrection)
    console.log("arc " + arc)
    console.log(links.maxSameHalf)
						return "M" + sxp + "," + syp + "A" + dr + "," + dr +" 0 0,1 " + txp + "," + typ;
                        //return "M" + sxp + "," + syp + "A" + arc + "," + arc + " 0 0," + links.sameArcDirection + " " + txp + "," + txp;
					  };

function specifyColor (color) {
	if (color === 'organic') {return '#2e7b50';}
	if (color === 'plastic') {return '#4682b4';}
	if (color === 'construction') {return '#cc8400';}
	if (color === 'food') {return '#ebda09';}
	if (color === 'msw') {return '#348984';}
	if (color === 'hazardous') {return '#893464';}
	return 'white';
};



function drawPath(sx,sy,tx,ty,links) {
    // draw arrow
// source: https://stackoverflow.com/questions/36579339/how-to-draw-line-with-arrow-using-d3-js
    var arrow = svg.append("marker")
        .attr("id", "arrow")
        .attr("refX", 6)
        .attr("refY", 6)
        .attr("markerWidth", 10)
        .attr("markerHeight", 10)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M 3 5.5 3.5 5.5" +      //left
            " 4 6 " +                       //up
            " 3.5 6.5  3 6.5 " +            //right
            "3.5 6")                        //down
        .style("fill", "black");


	var route = g.insert("path")
                   .attr("class", "route")
                    .attr("id","route")
                   .attr("d", makeArc(sx,sy,tx,ty,links))
				   .style("stroke", specifyColor (color))
                    .style("stroke-opacity", 0.75)
				   .style("stroke-width", strokeWidth)
                   //.style("stroke-dasharray", "9, 2")
                    .attr("marker-end", "url(#arrow)");
};

/*

Aktuelle AUFGABEN

        *** - Farbe nach type
        *** - StrokeWidth: Breite nach value
		        Vorgehen: value / maxValue * maxStrokeWidth
- Punkte
    *** Größe der Punkte abhängig nach in & outflows
    - PieChart mit Anteilen für in und outflows: https://bl.ocks.org/Andrew-Reid/838aa0957c6492eaf4590c5bc5830a84

- Richtung anzeigen: 1 arrow mit marker-start oder marker-end, aber: bei bend funktioniert es nicht (bend einfügen) und anzeige in bestimmtem abstand
    - arcTween: mit animation?
    -transition https://github.com/d3/d3-transition#transition_attrTween
    - chained transition (dashedarray?)https://bl.ocks.org/mbostock/70d5541b547cc222aa02

- bend anpassen nach Anzahl von flows: bzw bend nach typ, da an gleicher stelle sein soll?

- Beziers statt arcs??
    - Bedingung einfügen: wenn type gleiches target xy und source xy hat, dann hintereinander verlaufen
*/

			
</script>
</body>
</html>